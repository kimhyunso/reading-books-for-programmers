<h3>객체 지향프로그램(OOP)</h3>

    부품에 해당하는 객체들을 먼저 만들고 이것들을 하나씩 조립하여 합쳐 완성시키는 것
    객체란 : 현실세계에 있는 대상을 컴퓨터로 옮기는 것
    속성(properties) = 명사
    메소드(Module) = 동사

<dl>
    <dt>사람</dt>
    <dd>[속성] 이름, 나이 //필드에 해당</dd>
    <dd>[동작] 웃다, 먹다 //메소드에 해당</dd>
    <dt>자동차</dt>
    <dd>[속성] 색상, 속도 //필드에 해당</dd>
    <dd>[동작] 달린다, 멈춘다 //메소드에 해당</dd>
</dl>



<h4>객체간의 상호작용</h4>

​	객체(.)점 연산자를 붙여 호출한다.

~~~java
int result = Calculator.add(10,20);
~~~



<h4>객체간의 관계</h4>

​	완성품인 객체를 모델링하고 객체를 하나씩 설계한 후 조립하는 것



<h2>객체지향 프로그램의 특징</h2>

<dl>
   <dt>1. 캡슐화</dt>
   <dd>접근 제한자 사용</dd>
   <dt>2. 상속</dt>
   <dd>부모가 가지고 있는 재산을 자식에게 물려주는 것</dd>
   <dt>3. 다형성</dt>
   <dd>같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질</dd>
   <dd>예시) 밑에 코드</dd>
</dl>

~~~java
public interface Tire{
}

public class HyundaiTire implements Tire{
    
}

public class KumhoTire implements Tire{
    
}

public class RunClass{
    public static void main(String[] args){
        Tire tire;
        tire = new HyundaiTire();
        tire = new KumhoTire();
    }
}
~~~

<h3>객체와 클래스</h3>

<dl>
    <dt><b>객체 지향 프로그램 개발의 세 가지 단계</b></dt>
    <dd>1. 클래스 설계단계</dd>
    <dd>2. 설계된 클래스를 가지고 사용할 객체 생성</dd>
    <dd>3. 생상된 객체를 이용하는 것</dd>
</dl>



<h3>클래스 선언</h3>

​	클래스 이름은 대문자로 표기한다. 

~~~java
public class ClassName{
	public ClassName(){}
}
//객체 생성
ClassName className = new ClassName(); //생성자 호출
~~~

실행 클래스 : main()

나머지 클래스 : API[라이브러리 클래스들]



<h3>클래스의 구성 멤버</h3>

1. 필드 : 객체가 가지고 있는 정보들
2. 생성자 : 객체 생성 시, 초기화해주는 역활
3. 메소드 : 객체의 동작 [낙타 표기법(camelCase)로 표기함]

~~~java
public class ClassName{
    private int field1; //필드
    private static final int FIELD_2 = 100; //필드
    private String name; //필드
    
    public ClassName(){	//생성자
        
    }
    
    public ClassName(String name){	//생성자
        this.name = name;
    }
    
    public void methodOne(){	//메소드
        
    }
    
    public int methodTwo(){		//메소드
        return 20;
    }
    
    public void methodThree(String name){	//메소드
        this.name = name;
    }
}
~~~



<h4>필드 값 접근</h4>

​	클래스이름.필드 이름

​	생성자나 메소드에서 매개변수값과 필드의 이름이 같을 경우 : this 사용

~~~java
public class ClassName{
    public String name;
    public ClassName(String name){
        this.name = name;
    }
}

public class ClassMain{
    public static void main(String[] args){
        ClassName className = new ClassName("홍길동");	//생성자 호출
        className.name = "김자바";	//필드 호출
    }
}
~~~

다양한 생성자  : 오버로딩(Overroading)

~~~java
public class ClassName{
    private String name;
    private int sum;
    
    public ClassName(){}
    public ClassName(String name){
        this.name = name;
    }
    public ClassName(int sum){
        this.sum = sum;
    }
    public className(String name, int sum){
        this(name);
        this(sum);
    }
}
~~~

오버로딩에서 중복된 코드를 최소화 하기위해 this() 메소드를 사용할 수 있다.



<h4>정적 필드 선언</h4>

​	static 사용시 선언가능

~~~java
public class ClassName{
	static int number = 10;	//정적 필드 선언
    public static void method(){}	//정적 메소드 선언
	public static int add(int num1, int num2){}	//정적 메소드 선언
}
~~~

​	정적요소는 클래스이름.정적요소로 접근하는 것이 좋다

~~~java
public class ClassName{
	static int number = 10;
    public static void method(){}
}

public class MainClass{
 	public static void main(String[] arg){
        ClassName.number = 20;
        ClassName.method();
    }   
}
~~~



<h4>정적 초기화 블록</h4>

~~~java
public class ClassName{
    static int num1;
    static int num2;
    public static void method(){
        System.out.println("static method Running...");
    }
    
    static{
        num1 = 10;
        num2 = 20;
        method();
    }
}
~~~



<h2>싱글톤(Singleton)</h2>

​	단 한개의 객체만을 생성하겠다. 메모리 참조를 한 곳으로 참조 시키겠다.

1.  클래스 외부에서 new 연산자로 호출할 수 없도록 막음
2. 자신 타입인 외부에서 접근불가한 정적 필드 하나를 선언한다.
3. 외부에서 호출 가능한 정적 메소드 getInstance()를 선언하고, 정적 필드를 리턴한다.

~~~java
public class SingletonClass{
    private static SingletonClass singleton = new SingletonClass();
    private SingletonClass(){}
    public static SingletonClass getInstance(){
        return singleton;
    }
}

public class useClass{
    public static void main(String[] arg){
        //같은 객체 참조
        SingletonClass singleton1 = SingletonClass.getInstance();
        SingletonClass singleton2 = SingletonClass.getInstance();
    }
}
~~~



<h2>final 필드와 상수</h2>

​	final변수는 한번 초기화 시, 수정할 수 없는 필드이다.

~~~java
public class FinalField{
	final int finalField1 = 20;
    final int finalField2;
    public FinalField(int finalField2){	//생성자
        this.finalFiedl2 = finalFiedld2;
    }

}
~~~

<h3>상수(Static final)</h3>

​	불변의 값

​	공용성을 띄고 있다.

​	대문자로 쓰는 것이 관례

~~~java
public class StaticFinalField{
    static final int SOURCE_1 = 10;
    static final int SOURCE_2;
    static{
        System.out.println("Static Block Running...");
        SOURCE_2 = 100;
    	staticMethd();
    }
    public static void staticMethod(){
        System.out.println("staticMethod() Running...");
    }
    
}
~~~



<h3>패키지</h3>

​	클래스 이름이 동일하더라도 패키지(폴더)가 다르면 다른 클래스로 인식한다.

~~~java
//import 상위패키지.하위패키지.클래스
import java.util.Objects;
~~~



<h3>접근 제한자</h3>

<table>
    <tr>
    	<th>접근제한</th>
        <th>적용대상</th>
        <th>접근할 수 없는 클래스</th>
    </tr>
    <tr>
    	<td>public</td>
        <td>클래스, 필드, 생성자, 메소드</td>
        <td>없음(어디에서나 접근이 가능)</td>
    </tr>
    <tr>
    	<td>protected</td>
        <td>필드, 생성자, 메소드</td>
        <td>자식 클래스가 아닌 다른 패키지에 있는 <br>클래스들 접근불가</td>
    </tr>
    <tr>
    	<td>default</td>
        <td>클래스, 필드, 생성자, 메소드</td>
        <td>다른 패키지에 있는 클래스들 접근불가</td>
    </tr>
    <tr>
    	<td>private</td>
        <td>필드, 생성자, 메소드</td>
        <td>모든 외부 클래스들 접근 불가</td>
    </tr>
</table>

<h3>Getter와 Setter 메소드</h3>

<dl>
    <dt>객체는 외부에서 직접적으로 접근하는 것을 막는다</li>
    <dd>이유 : 객체의 무결성이 깨지기 때문에</dd>
    <dt>객체지향 프로그램은 메소드를 통해 데이터 변경하는 방법을 선호한다.</dt>
</dl>

~~~java
public class GetterSetter{
    private int speed;
    private boolean stop = true;
    
    public int getSpeed(){
        return speed;
    }
    public void setSpeed(int speed){
        this.speed = speed;
    }
    
    public void isStop(){
        return stop;
    }
    public void setStop(boolean stop){
        this.stop = stop;
    }
}
~~~



<h3>어노테이션(= 메타데이터)</h3>

​	컴파일 과정과 실행과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보

​	클래스, 필드, 메소드만 어노테이션 적용 가능

​	리플렉션 : 런타임 시에 클래스의 메타정보를 얻는 기능

~~~java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PrintAnnotation{
    String value() defualt "-";
    int number() default 15;
}

public class Service {
    @PrintAnnotation
    public void method1(){
        System.out.println("실행 내용1");
    }

    @PrintAnnotation("*")
    public void method2(){
        System.out.println("실행 내용2");
    }

    @PrintAnnotation(value="#", number=20)
    public void method3(){
        System.out.println("실행 내용3");
    }

}

public class PrintAnnotationEx{
	public static void main(String[] args){
        Method[] declaredMethods = Service.class.getDeclaredMethods();
        for(Method method : declaredMethods){
            if(method.isAnnotationPresent(PrintAnnotation.class)){
                
                PrintAnnotation printAnnotation =
                    method.getAnnotation(PrintAnnotation.class);

                System.out.println("["+method.getName()+"]");

                for(int i=0; i<printAnnotation.number(); i++)
                    System.out.print(printAnnotation.value());

                System.out.println();

                try{
                    method.invoke(new Service());
                }catch (Exception e){}
                System.out.println();
            }
        }
    }
}
~~~



















